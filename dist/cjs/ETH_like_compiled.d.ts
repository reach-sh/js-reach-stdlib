import { ethers } from 'ethers';
import * as shared_backend from './shared_backend';
import type { // =>
CBR_Address } from './CBR';
import type { // =>
ETH_Ty, AnyETH_Ty, EthLikeCompiledArgs } from './ETH_like_interfaces';
import { TypeDefs, Stdlib_Backend_Base } from './interfaces';
import { MkPayAmt } from './shared_impl';
export type { // =>
ETH_Ty, AnyETH_Ty, };
export type Token = CBR_Address;
export type PayAmt = MkPayAmt<Token>;
export type ContractInfo = string;
export declare function makeEthLikeCompiled(ethLikeCompiledArgs: EthLikeCompiledArgs): {
    typeDefs: TypeDefs<AnyETH_Ty>;
    stdlib: Stdlib_Backend_Base<string, string, AnyETH_Ty>;
    UInt_max: ethers.BigNumber;
    ctcAddrEq: (ctc_x: unknown, addr_y: unknown) => boolean;
    addressEq: (addr1: unknown, addr2: unknown) => boolean;
    digestEq: (x: unknown, y: unknown) => boolean;
    digest_xor: (x: string, y: string) => string;
    tokenEq: (x: unknown, y: unknown) => boolean;
    digest: (ts: AnyETH_Ty[], vs: unknown[]) => string;
    emptyContractInfo: string | number;
    checkedBigNumberify: (at: string, max: ethers.BigNumber, n: any) => ethers.BigNumber;
    protect: (t: any, v: unknown, ai?: string | undefined) => unknown;
    Array_asyncMap: <B>(as: any[][], f: (x: any[], i: number) => Promise<B>) => Promise<B[]>;
    Array_asyncReduce: <B_1>(as: any[][], b: B_1, f: (xs: any[], y: B_1, i: number) => Promise<B_1>) => Promise<B_1>;
    newMap: <K, A>(opts: shared_backend.MapOpts<AnyETH_Ty>) => shared_backend.LinearMap<K, A, AnyETH_Ty>;
    mapRef: <K_1, A_1>(m: shared_backend.LinearMap<K_1, A_1, AnyETH_Ty>, kt: AnyETH_Ty, k: K_1, vt: AnyETH_Ty) => Promise<shared_backend.MaybeRep<A_1>>;
    mapSet: <K_2, A_2>(m: shared_backend.LinearMap<K_2, A_2, AnyETH_Ty>, kt: AnyETH_Ty, k: K_2, vt: AnyETH_Ty, v: A_2 | undefined) => Promise<void>;
    bytesConcat: (b1: string, b2: string) => string;
    fromSome: <A_3>(mo: shared_backend.MaybeRep<A_3>, da: A_3) => A_3;
    assert: (b: boolean, message: string) => void;
    Array_set: <A_4>(arr: A_4[], idx: number, val: A_4) => A_4[];
    eq: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    ge: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    gt: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    le: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    lt: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    eq256: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    ge256: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    gt256: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    le256: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    lt256: (n1: shared_backend.num, n2: shared_backend.num) => boolean;
    bytesEq: (s1: string, s2: string) => boolean;
    bytes_xor: (x: string, y: string) => string;
    btoiLast8: (b: string) => ethers.BigNumber;
    stringDynConcat: (s1: string, s2: string) => string;
    uintToStringDyn: (n1: shared_backend.num) => string;
    uintToStringDyn256: (n1: shared_backend.num) => string;
    add: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeAdd: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    sub: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeSub: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    mod: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeMod: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    mul: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeMul: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    div: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeDiv: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    band: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    bior: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    bxor: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    sqrt: (n1: shared_backend.num, n2: shared_backend.num) => ethers.BigNumber;
    add256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeAdd256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    sub256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeSub256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    mod256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeMod256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    mul256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeMul256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    div256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    safeDiv256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    band256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    bior256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    bxor256: (x: shared_backend.num, y: shared_backend.num) => ethers.BigNumber;
    sqrt256: (n1: shared_backend.num, n2: shared_backend.num) => ethers.BigNumber;
    safeMuldiv: (x: shared_backend.num, y: shared_backend.num, z: shared_backend.num) => ethers.BigNumber;
    muldiv: (x: shared_backend.num, y: shared_backend.num, z: shared_backend.num) => ethers.BigNumber;
    cast: (from: import("./shared_impl").UIntTy, to: import("./shared_impl").UIntTy, x: shared_backend.num, truncate: boolean, chkOverflow: boolean) => ethers.BigNumber;
    T_Null: AnyETH_Ty;
    T_Bool: AnyETH_Ty;
    T_UInt: AnyETH_Ty;
    T_UInt256: AnyETH_Ty;
    T_Bytes: (len: number) => AnyETH_Ty;
    T_BytesDyn: AnyETH_Ty;
    T_StringDyn: AnyETH_Ty;
    T_Address: AnyETH_Ty;
    T_Contract: AnyETH_Ty;
    T_Digest: AnyETH_Ty;
    T_Token: AnyETH_Ty;
    T_Object: (tyMap: {
        [key: string]: AnyETH_Ty;
    }) => AnyETH_Ty;
    T_Data: (tyMap: {
        [key: string]: AnyETH_Ty;
    }) => AnyETH_Ty;
    T_Array: (ty: AnyETH_Ty, size: number) => AnyETH_Ty;
    T_Tuple: (tys: AnyETH_Ty[]) => AnyETH_Ty;
    T_Struct: (nameTyPairs: [string, AnyETH_Ty][]) => AnyETH_Ty;
    simMapDupe: <K_3, A_5>(sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, mapi: number, mapo: shared_backend.LinearMap<K_3, A_5, AnyETH_Ty>) => void;
    simMapRef: <K_4, A_6>(sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, mapi: number, kt: AnyETH_Ty, k: K_4, vt: AnyETH_Ty) => Promise<shared_backend.MaybeRep<A_6>>;
    simMapSet: <K_5, A_7>(sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, mapi: number, kt: AnyETH_Ty, k: K_5, vt: AnyETH_Ty, v: A_7 | undefined) => Promise<void>;
    simTokenNew: <A_8>(sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, n: any, s: any, u: any, m: any, p: ethers.BigNumber, d: ethers.BigNumber | undefined, ctr: A_8) => A_8;
    simContractNew: <A_9>(sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, cns: any, remote: import("./shared_impl").ISimRemote<string, string, AnyETH_Ty>, ctr: A_9) => A_9;
    simTokenBurn: (sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, tok: string, amt: ethers.BigNumber) => void;
    simTokenDestroy: (sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, tok: string) => void;
    simTokenAccepted_: (sim_r: import("./shared_impl").ISimRes<string, string, AnyETH_Ty>, addr: string, tok: string) => void;
};
//# sourceMappingURL=ETH_like_compiled.d.ts.map